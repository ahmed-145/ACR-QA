# ACR-QA Universal Rule Catalog
# Evidence-grounded definitions for RAG-enhanced explanations

SOLID-001:
  name: "Too Many Parameters"
  category: "design"
  severity: "medium"
  description: "Functions with more than 5 parameters violate Single Responsibility Principle"
  rationale: |
    Functions with many parameters are hard to test, understand, and maintain.
    Each parameter represents a dependency or responsibility. When a function
    needs many inputs, it's likely doing too much and should be split.
  remediation: "Extract related parameters into a dataclass or configuration object"
  example_good: |
    from dataclasses import dataclass
    
    @dataclass
    class UserConfig:
        username: str
        password: str
        email: str
    
    def create_user(config: UserConfig):
        print(f"Creating {config.username}")
  example_bad: |
    def create_user(username, password, email, phone, address, city, country):
        print(f"Creating {username}")  # Too many parameters!

IMPORT-001:
  name: "Unused Import"
  category: "style"
  severity: "low"
  description: "Import statement is never used in the file"
  rationale: |
    Unused imports clutter the namespace, slow down module loading,
    and confuse developers about what dependencies are actually needed.
  remediation: "Remove the import statement or use the imported module"
  example_good: |
    import os
    print(os.getcwd())  # os is used
  example_bad: |
    import os
    import sys  # Never used!
    print(os.getcwd())

VAR-001:
  name: "Unused Variable"
  category: "dead-code"
  severity: "low"
  description: "Variable is assigned but never referenced"
  rationale: |
    Unused variables indicate dead code, confuse readers about intent,
    and may hide bugs where the variable was meant to be used.
  remediation: "Remove the variable or use it in your code"
  example_good: |
    result = calculate_total()
    print(result)  # Variable is used
  example_bad: |
    result = calculate_total()
    unused_var = 42  # Never used!
    print(result)

SECURITY-001:
  name: "Dangerous eval() Usage"
  category: "security"
  severity: "high"
  description: "eval() executes arbitrary Python code and should never be used with user input"
  rationale: |
    eval() is a code execution vulnerability. An attacker can inject malicious
    code that will run with your application's privileges, leading to data theft,
    system compromise, or remote code execution.
  remediation: "Use ast.literal_eval() for safe evaluation of literals, or redesign to avoid dynamic evaluation"
  example_good: |
    import ast
    # Safe for literals only (strings, numbers, lists, dicts)
    data = ast.literal_eval(user_input)
  example_bad: |
    # DANGEROUS! User can execute arbitrary code
    result = eval(user_input)

PATTERN-001:
  name: "Mutable Default Argument"
  category: "best-practice"
  severity: "medium"
  description: "Using mutable objects (list, dict, set) as default function arguments"
  rationale: |
    Default arguments are created ONCE when the function is defined, not each
    time it's called. All calls share the same list/dict/set, causing unexpected
    behavior where changes persist across function calls.
  remediation: "Use None as default, then initialize the mutable object inside the function"
  example_good: |
    def add_item(item, items=None):
        if items is None:
            items = []
        items.append(item)
        return items
  example_bad: |
    def add_item(item, items=[]):  # BUG! All calls share same list
        items.append(item)
        return items

DUP-001:
  name: "Code Duplication"
  category: "duplication"
  severity: "medium"
  description: "Identical or nearly identical code blocks found in multiple locations"
  rationale: |
    Duplicated code violates the DRY (Don't Repeat Yourself) principle.
    When you need to fix a bug or add a feature, you must change it in
    multiple places, increasing the risk of inconsistencies and bugs.
  remediation: "Extract common logic into a shared function, class, or module"
  example_good: |
    def validate_email(email):
        return "@" in email and "." in email
    
    # Reuse in multiple places
    valid1 = validate_email(user1.email)
    valid2 = validate_email(user2.email)
  example_bad: |
    # File 1
    if "@" in user1.email and "." in user1.email:
        print("Valid")
    
    # File 2 - DUPLICATE!
    if "@" in user2.email and "." in user2.email:
        print("Valid")

DEAD-001:
  name: "Unused Code"
  category: "dead-code"
  severity: "low"
  description: "Function, class, or variable defined but never used"
  rationale: |
    Dead code increases maintenance burden, confuses developers,
    and may contain bugs that go unnoticed because the code never runs.
  remediation: "Remove unused code or document why it exists (if kept for future use)"
  example_good: |
    def calculate_total(items):
        return sum(items)
    
    # Function is actually called
    result = calculate_total([1, 2, 3])
  example_bad: |
    def calculate_total(items):
        return sum(items)
    
    def unused_function():  # Never called anywhere!
        pass

STYLE-001:
  name: "Line Too Long"
  category: "style"
  severity: "low"
  description: "Line exceeds maximum length (typically 88 or 120 characters)"
  rationale: |
    Long lines are hard to read, especially on smaller screens or in
    side-by-side diffs. Breaking lines improves readability.
  remediation: "Break line into multiple lines using parentheses or backslash"
  example_good: |
    result = some_function(
        argument1,
        argument2,
        argument3
    )
  example_bad: |
    result = some_function(argument1, argument2, argument3, argument4, argument5, argument6)

STYLE-002:
  name: "Missing Docstring"
  category: "style"
  severity: "low"
  description: "Public function or class lacks documentation"
  rationale: |
    Docstrings help others (and future you) understand what the code does,
    what parameters it expects, and what it returns.
  remediation: "Add a docstring explaining the function's purpose, parameters, and return value"
  example_good: |
    def calculate_total(items):
        """Calculate sum of all items.
        
        Args:
            items: List of numbers
            
        Returns:
            Sum of all items
        """
        return sum(items)
  example_bad: |
    def calculate_total(items):  # No docstring!
        return sum(items)

NAMING-001:
  name: "Bad Variable Name"
  category: "style"
  severity: "low"
  description: "Variable name is too short, unclear, or doesn't follow conventions"
  rationale: |
    Clear names make code self-documenting. Single-letter names (except
    in loops) or abbreviations force readers to guess the meaning.
  remediation: "Use descriptive names that explain what the variable represents"
  example_good: |
    customer_count = len(customers)
    total_price = calculate_total(items)
  example_bad: |
    c = len(customers)  # What is 'c'?
    tp = calculate_total(items)  # What is 'tp'?
COMPLEXITY-001:
  name: "High Cyclomatic Complexity"
  category: "design"
  severity: "medium"
  description: "Function has high cyclomatic complexity making it hard to test and maintain"
  rationale: |
    Cyclomatic complexity measures the number of independent paths through code.
    High complexity (>10) indicates too many branches (if/else/loops), making
    the function hard to understand, test, and maintain. Each additional path
    requires a new test case.
  remediation: "Refactor into smaller functions with single responsibilities"
  example_good: |
    def process_user(user):
        if not validate_user(user):
            return False
        if not check_permissions(user):
            return False
        return save_user(user)
  example_bad: |
    def process_user(user):
        if user.age < 18:
            if user.has_parent:
                if user.parent.verified:
                    # ... many more nested conditions
                    pass

# ===== NEW RULES (MEDIUM Priority - Expand Knowledge Base) =====

EXCEPT-001:
  name: "Bare Except Clause"
  category: "best-practice"
  severity: "medium"
  description: "Using bare 'except:' catches all exceptions including SystemExit and KeyboardInterrupt"
  rationale: |
    Bare except clauses catch ALL exceptions, including ones you probably don't want
    to catch like KeyboardInterrupt (Ctrl+C) and SystemExit. This can make debugging
    difficult and hide real errors.
  remediation: "Catch specific exceptions, or at minimum use 'except Exception:'"
  example_good: |
    try:
        result = risky_operation()
    except ValueError as e:
        logger.error(f"Invalid value: {e}")
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
  example_bad: |
    try:
        result = risky_operation()
    except:  # BAD! Catches everything including Ctrl+C
        pass

HARDCODE-001:
  name: "Hardcoded Secret"
  category: "security"
  severity: "high"
  description: "Hardcoded password, API key, or secret in source code"
  rationale: |
    Hardcoded secrets in source code can be exposed through version control,
    code sharing, or decompilation. Once a secret is in git history, it's
    extremely difficult to fully remove. Attackers actively scan for such leaks.
  remediation: "Use environment variables or a secrets manager (e.g., AWS Secrets Manager, HashiCorp Vault)"
  example_good: |
    import os
    api_key = os.getenv('API_KEY')
    password = os.getenv('DB_PASSWORD')
  example_bad: |
    api_key = "sk-1234567890abcdef"  # EXPOSED!
    password = "admin123"  # EXPOSED!

ASYNC-001:
  name: "Async/Await Issue"
  category: "best-practice"
  severity: "medium"
  description: "Incorrect use of async/await patterns"
  rationale: |
    Async functions that don't await properly can lead to race conditions,
    unhandled promises, or blocking behavior. Missing await means the coroutine
    won't execute as expected.
  remediation: "Ensure all async calls are properly awaited or gathered"
  example_good: |
    async def fetch_data():
        result = await api_client.get('/data')
        return result
  example_bad: |
    async def fetch_data():
        result = api_client.get('/data')  # Missing await!
        return result

TYPE-001:
  name: "Type Annotation Issue"
  category: "style"
  severity: "low"
  description: "Missing or incorrect type annotations"
  rationale: |
    Type annotations improve code readability, enable better IDE support,
    and allow static type checkers like mypy to catch bugs before runtime.
  remediation: "Add type hints to function parameters and return values"
  example_good: |
    def greet(name: str) -> str:
        return f"Hello, {name}!"
  example_bad: |
    def greet(name):  # No type hints
        return f"Hello, {name}!"

# Security rules for Bandit integration
SECURITY-002:
  name: "Assert Used in Production"
  category: "security"
  severity: "low"
  description: "Assert statements are removed when Python runs with -O flag"
  rationale: |
    Assert statements are stripped out when Python runs in optimized mode (-O).
    Never use assert for security checks or input validation.
  remediation: "Use proper if/raise statements for validation"
  example_good: |
    if not user.is_authenticated:
        raise PermissionError("User not authenticated")
  example_bad: |
    assert user.is_authenticated  # Removed in production with -O!

SECURITY-005:
  name: "Hardcoded Password"
  category: "security"
  severity: "high"
  description: "Password or secret hardcoded in source code"
  rationale: |
    Hardcoded passwords can be extracted from source code or binaries.
    Use environment variables or secure secret management.
  remediation: "Use os.getenv() or a secrets manager"
  example_good: |
    password = os.getenv('DB_PASSWORD')
  example_bad: |
    password = "SuperSecret123"  # EXPOSED!

SECURITY-008:
  name: "Unsafe Pickle Usage"
  category: "security"
  severity: "high"
  description: "Pickle can execute arbitrary code during deserialization"
  rationale: |
    Pickle is not secure against maliciously crafted data. An attacker can
    craft a pickle that executes arbitrary code when unpickled.
  remediation: "Use JSON or other safe serialization formats for untrusted data"
  example_good: |
    import json
    data = json.loads(user_input)
  example_bad: |
    import pickle
    data = pickle.loads(user_input)  # DANGEROUS!

SECURITY-021:
  name: "Shell Injection Risk"
  category: "security"
  severity: "high"
  description: "Using shell=True in subprocess with user input"
  rationale: |
    shell=True passes the command through the shell, enabling command injection
    if any part of the command comes from user input.
  remediation: "Use shell=False and pass arguments as a list"
  example_good: |
    import subprocess
    subprocess.run(['ls', '-la', user_dir], shell=False)
  example_bad: |
    import subprocess
    subprocess.run(f"ls -la {user_dir}", shell=True)  # INJECTION RISK!

SECURITY-027:
  name: "SQL Injection Risk"
  category: "security"
  severity: "high"
  description: "Hardcoded SQL with string formatting vulnerable to injection"
  rationale: |
    String formatting in SQL queries allows attackers to inject malicious SQL.
    This can lead to data theft, modification, or complete database compromise.
  remediation: "Use parameterized queries with placeholders"
  example_good: |
    cursor.execute("SELECT * FROM users WHERE id = %s", (user_id,))
  example_bad: |
    cursor.execute(f"SELECT * FROM users WHERE id = {user_id}")  # INJECTION!

# ===== PERFORMANCE RULES =====

PERF-001:
  name: "Inefficient Loop"
  category: "performance"
  severity: "medium"
  description: "Loop performs unnecessary operations or repeated calculations"
  rationale: |
    Loops that recalculate invariant values or perform unnecessary operations
    waste CPU cycles. Moving invariant calculations outside loops improves performance.
  remediation: "Move invariant calculations outside the loop"
  example_good: |
    upper_limit = len(items)
    for i in range(upper_limit):
        process(items[i])
  example_bad: |
    for i in range(len(items)):  # len() called every iteration
        process(items[i])

PERF-002:
  name: "String Concatenation in Loop"
  category: "performance"
  severity: "medium"
  description: "Using + for string concatenation in loops is O(n²)"
  rationale: |
    Strings are immutable in Python. Using + in a loop creates a new string
    object each iteration, leading to O(n²) complexity. Use join() instead.
  remediation: "Use ''.join() or list comprehension"
  example_good: |
    result = ''.join(str(x) for x in items)
  example_bad: |
    result = ""
    for x in items:
        result += str(x)  # Creates new string each time!

# ===== DOCUMENTATION RULES =====

DOC-001:
  name: "Missing Docstring"
  category: "documentation"
  severity: "low"
  description: "Public function/class lacks docstring"
  rationale: |
    Docstrings are the primary way to document Python code. They enable
    auto-generated documentation and help other developers understand your code.
  remediation: "Add docstring with description, args, and returns"
  example_good: |
    def calculate_total(items: list) -> float:
        """Calculate total price of items.
        
        Args:
            items: List of item dictionaries with 'price' key
            
        Returns:
            Total price as float
        """
        return sum(item['price'] for item in items)
  example_bad: |
    def calculate_total(items):
        return sum(item['price'] for item in items)

DOC-002:
  name: "Outdated Comment"
  category: "documentation"
  severity: "low"
  description: "Comment contradicts the code"
  rationale: |
    Outdated comments are worse than no comments - they mislead developers
    and can cause bugs when code is modified based on incorrect documentation.
  remediation: "Update or remove outdated comments"
  example_good: |
    # Calculate average (mean)
    avg = sum(values) / len(values)
  example_bad: |
    # Calculate median
    avg = sum(values) / len(values)  # Actually calculates mean!

# ===== ERROR HANDLING RULES =====

ERROR-001:
  name: "Silent Exception"
  category: "best-practice"
  severity: "medium"
  description: "Exception caught but not logged or handled"
  rationale: |
    Silent exceptions hide errors, making debugging impossible. Always log
    exceptions or re-raise them after cleanup.
  remediation: "Log the exception or re-raise after cleanup"
  example_good: |
    try:
        risky_operation()
    except Exception as e:
        logger.error(f"Operation failed: {e}")
        cleanup()
        raise
  example_bad: |
    try:
        risky_operation()
    except Exception:
        pass  # Silent failure!

ERROR-002:
  name: "Catching Too Broad"
  category: "best-practice"
  severity: "low"
  description: "Catching Exception instead of specific exceptions"
  rationale: |
    Catching broad exceptions can hide unexpected errors. Catch specific
    exceptions you know how to handle.
  remediation: "Catch specific exception types"
  example_good: |
    try:
        value = int(user_input)
    except ValueError:
        print("Invalid number")
  example_bad: |
    try:
        value = int(user_input)
    except Exception:  # Too broad!
        print("Invalid number")

# ===== CONCURRENCY RULES =====

THREAD-001:
  name: "Race Condition"
  category: "concurrency"
  severity: "high"
  description: "Shared state accessed without synchronization"
  rationale: |
    Multiple threads accessing shared state without locks can cause race
    conditions, leading to data corruption and unpredictable behavior.
  remediation: "Use locks, queues, or thread-safe data structures"
  example_good: |
    from threading import Lock
    lock = Lock()
    
    def increment():
        with lock:
            global counter
            counter += 1
  example_bad: |
    def increment():
        global counter
        counter += 1  # Race condition!

# ===== LOGGING RULES =====

LOG-001:
  name: "Logging Sensitive Data"
  category: "security"
  severity: "high"
  description: "Logging passwords, tokens, or PII"
  rationale: |
    Logs are often stored insecurely and may be accessible to unauthorized
    parties. Never log sensitive data like passwords or API keys.
  remediation: "Redact sensitive data before logging"
  example_good: |
    logger.info(f"User {user_id} logged in")
  example_bad: |
    logger.info(f"User {username} logged in with password {password}")

# ===== RESOURCE MANAGEMENT =====

RESOURCE-001:
  name: "File Not Closed"
  category: "best-practice"
  severity: "medium"
  description: "File opened without using context manager"
  rationale: |
    Files not closed properly can lead to resource leaks, especially in
    long-running applications. Use 'with' statement for automatic cleanup.
  remediation: "Use 'with' statement for file operations"
  example_good: |
    with open('file.txt') as f:
        data = f.read()
  example_bad: |
    f = open('file.txt')
    data = f.read()
    # File might not be closed if exception occurs!

# ===== API DESIGN RULES =====

API-001:
  name: "Mutable Default Argument"
  category: "best-practice"
  severity: "medium"
  description: "Using mutable object as default argument"
  rationale: |
    Mutable default arguments are shared across all function calls, leading
    to unexpected behavior. Use None and create new object inside function.
  remediation: "Use None as default, create mutable inside function"
  example_good: |
    def add_item(item, items=None):
        if items is None:
            items = []
        items.append(item)
        return items
  example_bad: |
    def add_item(item, items=[]):  # Shared across calls!
        items.append(item)
        return items

INPUT-001:
  name: "Missing Input Validation"
  category: "security"
  severity: "high"
  description: "User input used without validation"
  rationale: |
    Unvalidated input can lead to injection attacks, crashes, or unexpected
    behavior. Always validate and sanitize user input.
  remediation: "Validate input type, range, and format"
  example_good: |
    def set_age(age):
        if not isinstance(age, int) or age < 0 or age > 150:
            raise ValueError("Invalid age")
        self.age = age
  example_bad: |
    def set_age(age):
        self.age = age  # No validation!


# ===== ADDITIONAL RULES (Phase 1 Complete) =====

COMPARE-001:
  name: "Improper None Comparison"
  category: "best-practice"
  severity: "low"
  description: "Using == instead of 'is' to compare with None"
  rationale: |
    In Python, None is a singleton. Using == compares values and may invoke
    __eq__, while 'is' compares identity directly. Always use 'is' for None.
  remediation: "Use 'if x is None' instead of 'if x == None'"
  example_good: |
    if x is None:
        handle_none()
  example_bad: |
    if x == None:  # Should use 'is'
        handle_none()

GLOBAL-001:
  name: "Global Variable Modification"
  category: "design"
  severity: "medium"
  description: "Modifying global variables inside functions"
  rationale: |
    Global variables create hidden dependencies and make testing difficult.
    Functions that modify globals have side effects that are hard to track.
  remediation: "Pass as parameter or use class attributes"
  example_good: |
    def increment(counter):
        return counter + 1
    count = increment(count)
  example_bad: |
    count = 0
    def increment():
        global count
        count += 1  # Hidden side effect!

MAGIC-001:
  name: "Magic Number"
  category: "style"
  severity: "low"
  description: "Hardcoded numeric literals without named constants"
  rationale: |
    Magic numbers make code hard to understand. Named constants explain
    the purpose and allow easy updates across the codebase.
  remediation: "Define constants with descriptive names"
  example_good: |
    MAX_RETRIES = 3
    TIMEOUT_SECONDS = 30
    for i in range(MAX_RETRIES):
        try_connection(timeout=TIMEOUT_SECONDS)
  example_bad: |
    for i in range(3):  # What is 3?
        try_connection(timeout=30)  # What is 30?

PATH-001:
  name: "Path Traversal Vulnerability"
  category: "security"
  severity: "high"
  description: "User input used directly in file paths without sanitization"
  rationale: |
    Attackers can use '../' sequences to access files outside the intended
    directory, potentially reading sensitive files or overwriting system files.
  remediation: "Use os.path.basename() or validate against allowed paths"
  example_good: |
    import os
    safe_name = os.path.basename(user_input)
    path = os.path.join('/uploads', safe_name)
  example_bad: |
    path = '/uploads/' + user_input  # User can input '../../../etc/passwd'

REGEX-001:
  name: "ReDoS Vulnerability"
  category: "security"
  severity: "medium"
  description: "Regular expression vulnerable to catastrophic backtracking"
  rationale: |
    Certain regex patterns can cause exponential time complexity with crafted
    input, allowing denial of service attacks. Avoid nested quantifiers.
  remediation: "Use atomic groups, possessive quantifiers, or rewrite pattern"
  example_good: |
    import re
    pattern = r'^[a-z]+$'  # Simple, linear time
  example_bad: |
    pattern = r'^(a+)+$'  # Nested quantifiers - exponential time!

RETURN-001:
  name: "Inconsistent Return Types"
  category: "best-practice"
  severity: "medium"
  description: "Function returns different types in different branches"
  rationale: |
    Inconsistent return types make code unpredictable and can cause runtime
    errors. Functions should return the same type consistently.
  remediation: "Return consistent types or use Optional[Type]"
  example_good: |
    def get_user(id: int) -> Optional[User]:
        if id in users:
            return users[id]
        return None  # Consistent with Optional
  example_bad: |
    def get_user(id):
        if id in users:
            return users[id]  # Returns User
        return "Not found"  # Returns string!

ASSERT-001:
  name: "Assert for Input Validation"
  category: "security"
  severity: "medium"
  description: "Using assert for input validation instead of proper checks"
  rationale: |
    Assert statements are removed with -O flag. Never use assert for
    input validation or security checks in production code.
  remediation: "Use if/raise for validation"
  example_good: |
    if not user.is_admin:
        raise PermissionError("Admin required")
  example_bad: |
    assert user.is_admin, "Admin required"  # Removed with -O!

PRINT-001:
  name: "Debug Print Statement"
  category: "style"
  severity: "low"
  description: "Print statements left in production code"
  rationale: |
    Print statements in production code clutter output and may expose
    sensitive information. Use proper logging instead.
  remediation: "Replace with logging.debug() or remove"
  example_good: |
    import logging
    logging.debug(f"Processing user {user_id}")
  example_bad: |
    print(f"DEBUG: user = {user}")  # Should use logging
